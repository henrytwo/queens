<!--
Rules:
- exactly one piece in each row
- exactly one piece in each col
- exactly one piece in each color region
- colored cells must be connected to each other
- pieces cannot be adjacent to each other (side by side or diagonal)

Pressing a cell once will mark it X to show it's eliminated, and pressing it once again will attempt to place a piece.

You must also verify that the generated board satisfies the parameters specified by the user, and if it is not possible show an alert explaining why.

If a piece is placed down, mark any cells that should be eliminated with an X, but these must be removed if that piece is removed. Do not remove
manually placed pieces.
-->


<!DOCTYPE html>
<html>
<head>
    <title>Crown Placement Game</title>
    <style>
        .container {
            text-align: center;
            font-family: Arial, sans-serif;
        }
        .board {
            display: grid;
            gap: 2px;
            margin: 20px auto;
            background: #333;
            padding: 2px;
            border-radius: 5px;
        }
        .cell {
            width: 30px;
            height: 30px;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            cursor: pointer;
            border: 1px solid #ccc;
            transition: all 0.3s ease;
        }
        .cell.x {
            background: #ffcccc;
        }
        .cell.crown {
            background: #ccccff;
        }
    </style>
</head>
<body>
    <div class="container">
        <div>
            <select id="size">
                <option value="4">4x4</option>
                <option value="5">5x5</option>
                <option value="6">6x6</option>
                <option value="7">7x7</option>
                <option value="8">8x8</option>
            </select>
            <select id="colorCount">
                <option value="2">2 Colors</option>
                <option value="3">3 Colors</option>
                <option value="4">4 Colors</option>
                <option value="5">5 Colors</option>
            </select>
            <button onclick="generateBoard()">Start</button>
        </div>
        <div id="board" class="board"></div>
    </div>

    <script>
        let boardSize = 4;
        let colorCount = 2;
        let board = [];
        let crowns = [];
        let xMarks = new Set();
        let colors = {};

        function generateBoard() {
            // Reset the board
            crowns = [];
            xMarks.clear();
            const boardDiv = document.getElementById('board');
            boardDiv.innerHTML = '';

            // Get parameters
            boardSize = parseInt(document.getElementById('size').value);
            colorCount = parseInt(document.getElementById('colorCount').value);

            // Check if it's possible to create valid regions
            if (colorCount > boardSize || (boardSize * boardSize) / colorCount < 4) {
                alert('Impossible to create a valid board with the specified parameters.');
                return;
            }

            // Create an empty grid
            const colorGrid = Array.from({ length: boardSize }, () => 
                Array(boardSize).fill(null));

            // Calculate the size of each color region
            const regionSize = Math.floor((boardSize * boardSize) / colorCount);
            const remainingCells = (boardSize * boardSize) % colorCount;

            // Assign starting positions for each color to ensure they're spread out
            const startingPositions = [];
            for (let c = 0; c < colorCount; c++) {
                const quadrant = Math.floor(c / (Math.ceil(colorCount / 2)));
                const x = Math.floor((c % Math.ceil(colorCount / 2))) * Math.ceil(boardSize / 2);
                const y = quadrant * Math.ceil(boardSize / 2);
                startingPositions.push([x, y]);
            }

            // Function to create a connected region using DFS
            const createRegion = async (startX, startY, color) => {
                const visited = new Set();
                const stack = [[startX, startY]];
                visited.add(`${startX},${startY}`);
                colorGrid[startX][startY] = color;

                while (stack.length < regionSize + (color < remainingCells ? 1 : 0)) {
                    const [x, y] = stack[stack.length - 1];
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    let validDirections = directions.filter(([dx, dy]) => {
                        const nx = x + dx;
                        const ny = y + dy;
                        return nx >= 0 && nx < boardSize && ny >= 0 && ny < boardSize &&
                            colorGrid[nx][ny] === null && !visited.has(`${nx},${ny}`);
                    });

                    if (validDirections.length > 0) {
                        const [dx, dy] = validDirections[Math.floor(Math.random() * validDirections.length)];
                        const nx = x + dx;
                        const ny = y + dy;
                        visited.add(`${nx},${ny}`);
                        colorGrid[nx][ny] = color;
                        stack.push([nx, ny]);
                        // Animate the cell
                        await animateCell(nx, ny, color);
                    } else {
                        stack.pop();
                    }
                }
            };

            // Animate cell coloring
            const animateCell = (x, y, color) => {
                return new Promise(resolve => {
                    const cell = document.querySelector(`[data-row="${x}"][data-col="${y}"]`);
                    if (cell) {
                        cell.style.backgroundColor = getColor(color);
                        resolve();
                    }
                });
            };

            // Generate the board with animation
            const generateBoardAsync = async () => {
                boardDiv.style.gridTemplateColumns = `repeat(${boardSize}, 30px)`;
                
                // Create empty cells first
                for (let i = 0; i < boardSize; i++) {
                    for (let j = 0; j < boardSize; j++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell';
                        cell.dataset.row = i;
                        cell.dataset.col = j;
                        cell.onclick = () => handleCellClick(i, j);
                        boardDiv.appendChild(cell);
                    }
                }

                // Create regions for each color with animation
                for (let c = 0; c < colorCount; c++) {
                    const size = regionSize + (c < remainingCells ? 1 : 0);
                    await createRegion(...startingPositions[c], c);
                }
            };

            generateBoardAsync();
        }

        function getColor(colorIndex) {
            const colors = [
                '#FF6B6B', // Red
                '#4ECDC4', // Teal
                '#45B7D1', // Blue
                '#96CEB4', // Light Green
                '#FFEEAD'  // Yellow
            ];
            return colors[colorIndex % colors.length];
        }

        function handleCellClick(row, col) {
            const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
            
            if (cell.textContent === '♔') {
                crowns = crowns.filter(c => c.row !== row || c.col !== col);
                cell.textContent = '';
                cell.classList.remove('crown');
                updateXMarks();
            } else if (cell.textContent === '×') {
                cell.textContent = '';
                cell.classList.remove('x');
                xMarks.delete(`${row},${col}`);
            } else {
                if (isValidCrownPosition(row, col)) {
                    crowns.push({row, col});
                    cell.textContent = '♔';
                    cell.classList.add('crown');
                    updateXMarks();
                } else {
                    if (!xMarks.has(`${row},${col}`)) {
                        cell.textContent = '×';
                        cell.classList.add('x');
                        xMarks.add(`${row},${col}`);
                    } else {
                        alert('Illegal move!');
                    }
                }
            }
        }

        function isValidCrownPosition(row, col) {
            return !crowns.some(c => c.row === row || c.col === col ||
                document.querySelector(`[data-row="${c.row}"][data-col="${c.col}"]`).dataset.color ===
                document.querySelector(`[data-row="${row}"][data-col="${col}"]`).dataset.color);
        }

        function updateXMarks() {
            document.querySelectorAll('.cell').forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                
                if (!cell.textContent) {
                    const isInvalid = crowns.some(c => c.row === row || c.col === col ||
                        cell.dataset.color === document.querySelector(`[data-row="${c.row}"][data-col="${c.col}"]`).dataset.color);
                    
                    if (isInvalid) {
                        if (!xMarks.has(`${row},${col}`)) {
                            cell.textContent = '×';
                            cell.classList.add('x');
                            xMarks.add(`${row},${col}`);
                        }
                    } else {
                        cell.textContent = '';
                        cell.classList.remove('x');
                        xMarks.delete(`${row},${col}`);
                    }
                }
            });
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Board</title>
    <style>
        .board {
            display: grid;
            grid-template-columns: repeat(8, 50px);
            grid-template-rows: repeat(8, 50px);
            gap: 2px;
        }

        .cell {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <div class="board" id="board"></div>
    <script>
        class Board {
            constructor(size) {
                this.size = size;
                this.board = Array(size).fill(0).map(() => Array(size).fill(0));
                this.solutions = this._generateSolutions(1000);
                if (this.solutions !== null) {
                    this._generateColors();
                } else {
                    console.log("Failed to generate solutions after 1000 attempts.");
                }
            }

            _generateSolutions(maxAttempts) {
                let attempts = 0;
                while (attempts < maxAttempts) {
                    let solutions = new Set();
                    let availableSolutions = new Set();

                    for (let i = 0; i < this.size; i++) {
                        for (let j = 0; j < this.size; j++) {
                            availableSolutions.add(`${i},${j}`);
                        }
                    }

                    let self = this;

                    function _selectCoordinate() {
                        if (availableSolutions.size === 0) {
                            return null;
                        }

                        let idx = Math.floor(Math.random() * availableSolutions.size);
                        let i, j;
                        let arr = Array.from(availableSolutions);
                        let coord = arr[idx].split(',').map(Number);
                        i = coord[0];
                        j = coord[1];

                        // Remove the 8 adjacent cells too, in addition to the one we just selected.
                        for (let ni = i - 1; ni <= i + 1; ni++) {
                            for (let nj = j - 1; nj <= j + 1; nj++) {
                                if (availableSolutions.has(`${ni},${nj}`)) {
                                    availableSolutions.delete(`${ni},${nj}`);
                                }
                            }
                        }

                        // Remove everything in the same row.
                        for (let nj = 0; nj < self.size; nj++) {
                            if (availableSolutions.has(`${i},${nj}`)) {
                                availableSolutions.delete(`${i},${nj}`);
                            }
                        }

                        // Remove everything in the same column.
                        for (let ni = 0; ni < self.size; ni++) {
                            if (availableSolutions.has(`${ni},${j}`)) {
                                availableSolutions.delete(`${ni},${j}`);
                            }
                        }

                        return [i, j];
                    }

                    for (let _ = 0; _ < this.size; _++) {
                        let solution = _selectCoordinate();

                        if (solution) {
                            solutions.add(solution.join(','));
                        } else {
                            break;
                        }
                    }

                    if (solutions.size === this.size) {
                        return solutions;
                    }

                    attempts++;
                }

                return null;
            }

            _getNeighbours(i, j) {
                let next = [
                    [-1, 0],
                    [1, 0],
                    [0, -1],
                    [0, 1],
                ];

                let neighbours = [];

                for (let [dx, dy] of next) {
                    let nx = i + dx;
                    let ny = j + dy;

                    if (0 <= nx && nx < this.size && 0 <= ny && ny < this.size) {
                        neighbours.push([nx, ny]);
                    }
                }

                return neighbours;
            }

            _getAdjacentCells(i, j) {
                let next = [
                    [-1, -1],
                    [-1, 0],
                    [-1, 1],
                    [0, -1],
                    [0, 1],
                    [1, -1],
                    [1, 0],
                    [1, 1],
                ];

                let adjacentCells = [];

                for (let [dx, dy] of next) {
                    let nx = i + dx;
                    let ny = j + dy;

                    if (0 <= nx && nx < this.size && 0 <= ny && ny < this.size) {
                        adjacentCells.push([nx, ny]);
                    }
                }

                return adjacentCells;
            }

            _fillHoles() {
                let q = [];

                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        if (this.board[i][j] === 0) {
                            for (let [nx, ny] of this._getNeighbours(i, j)) {
                                let color = this.board[nx][ny];
                                if (color !== 0) {
                                    q.push([i, j, color]);
                                    break;
                                }
                            }
                        }
                    }
                }

                while (q.length > 0) {
                    let [i, j, color] = q.shift();

                    if (this.board[i][j] === 0) {
                        this.board[i][j] = color;

                        for (let [nx, ny] of this._getNeighbours(i, j)) {
                            q.push([nx, ny, color]);
                        }
                    }
                }
            }

            _fill(color, solution, cellCount) {
                let q = [];

                q.push(solution);
                for (let _ = 0; _ < Math.min(cellCount, this.size * this.size / this.size); _++) {
                    if (q.length > 0) {
                        let [i, j] = q.shift();

                        this.board[i][j] = color;

                        for (let [nx, ny] of this._getNeighbours(i, j)) {
                            if (!this.solutions.has(`${nx},${ny}`) && this.board[nx][ny] === 0) {
                                q.push([nx, ny]);
                            }
                        }
                    }
                }
            }

            _generateColors() {
                // Generate main colors
                let idx = 1;
                for (let solution of this.solutions) {
                    let [i, j] = solution.split(',').map(Number);
                    let color = idx++;
                    let cellCount = Math.floor(Math.random() * (this.size * this.size / (this.size * 2))) + 1;

                    this._fill(color, [i, j], cellCount);
                }

                // Fill in any remaining holes with nearest adjacent color
                this._fillHoles();
            }

            render() {
                let boardElement = document.getElementById('board');
                boardElement.innerHTML = '';
                boardElement.style.gridTemplateColumns = `repeat(${this.size}, 50px)`;
                boardElement.style.gridTemplateRows = `repeat(${this.size}, 50px)`;

                for (let i = 0; i < this.size; i++) {
                    for (let j = 0; j < this.size; j++) {
                        let cellElement = document.createElement('div');
                        cellElement.classList.add('cell');

                        let color = this.board[i][j];
                        let solution = this.solutions.has(`${i},${j}`);

                        if (solution) {
                            cellElement.style.background = this.getColor(color);
                            cellElement.innerText = 'ðŸ‘‘';
                        } else {
                            cellElement.style.background = this.getColor(color);
                        }

                        boardElement.appendChild(cellElement);
                    }
                }
            }

            getColor(color) {
                let colors = [];
                let step = 1.0 / this.size;
                for (let i = 0; i < this.size; i++) {
                    colors.push(this.hsvToRgb(i * step, 1, 1));
                }

                return colors[color - 1] || '#FFFFFF';
            }

            hsvToRgb(h, s, v) {
                let r, g, b;

                let i = Math.floor(h * 6);
                let f = h * 6 - i;
                let p = v * (1 - s);
                let q = v * (1 - f * s);
                let t = v * (1 - (1 - f) * s);

                switch (i % 6) {
                    case 0:
                        r = v;
                        g = t;
                        b = p;
                        break;
                    case 1:
                        r = q;
                        g = v;
                        b = p;
                        break;
                    case 2:
                        r = p;
                        g = v;
                        b = t;
                        break;
                    case 3:
                        r = p;
                        g = q;
                        b = v;
                        break;
                    case 4:
                        r = t;
                        g = p;
                        b = v;
                        break;
                    case 5:
                        r = v;
                        g = p;
                        b = q;
                        break;
                }

                return `#${Math.round(r * 255).toString(16).padStart(2, '0')}${Math.round(g * 255).toString(16).padStart(2, '0')}${Math.round(b * 255).toString(16).padStart(2, '0')}`;
            }
        }

        let board = new Board(8);
        if (board.solutions !== null) {
            board.render();
        } else {
            console.log("Failed to generate solutions after 1000 attempts.");
        }
    </script>
</body>
</html>